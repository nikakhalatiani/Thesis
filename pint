#!/usr/bin/env python3

"""
Property Inference Engine CLI
A tool for inferring mathematical properties of functions through automated testing.
"""

import argparse
import sys
import os
import time
import json
import inspect
import importlib.util
from typing import Any

from core.properties import create_standard_registry, create_minimal_registry
from input.input_parser import InputParser
from config.property_inference_config import PropertyInferenceConfig
from core.function_under_test import FunctionUnderTest, ComparisonStrategy
from core.property_inference_engine import PropertyInferenceEngine
from config.grammar_config import GrammarConfig


def load_user_module(path: str):
    """Load a Python module from a file path."""
    try:
        spec = importlib.util.spec_from_file_location("user_defined_functions", path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load module from {path}")
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module
    except Exception as e:
        raise ImportError(f"Failed to load module from {path}: {e}") from e


def get_user_classes(module, class_name: str | None = None) -> list[tuple[str, type]]:
    """Extract relevant classes from user module with proper filtering."""
    if class_name:
        if not hasattr(module, class_name):
            raise ValueError(f"Class '{class_name}' not found in module")
        return [(class_name, getattr(module, class_name))]

    # Get all classes defined in this module (not imported)
    classes = []
    for name, obj in inspect.getmembers(module, inspect.isclass):
        if obj.__module__ == module.__name__:
            classes.append((name, obj))

    if not classes:
        available = [name for name, obj in inspect.getmembers(module, inspect.isclass)]
        raise ValueError(f"No user-defined classes found in module. Available classes: {available}")

    return classes


def extract_overrides(module) -> dict[str, dict[str, Any]]:
    """Extract all function overrides from module using a unified approach."""
    overrides = {
        'converter': {},
        'grammar': {},
        'parser': {},
        'comparator': {}
    }

    override_patterns = {
        'converter_': 'converter',
        'grammar_': 'grammar',
        'parser_': 'parser',
        'comparator_': 'comparator'
    }

    for name, value in vars(module).items():
        for prefix, override_type in override_patterns.items():
            if name.startswith(prefix):
                func_name = name[len(prefix):]
                overrides[override_type][func_name] = value
                break

    return overrides


def process_grammar_override(func_name: str, value: Any, default_grammar) -> GrammarConfig:
    """Process grammar override with proper validation."""
    if isinstance(value, GrammarConfig):
        return value
    elif isinstance(value, str):
        return GrammarConfig(value)
    elif isinstance(value, (list, tuple)):
        try:
            if value and isinstance(value[0], str) and value[0].endswith(".fan"):
                return GrammarConfig(value[0], extra_constraints=value[1:])
            else:
                return GrammarConfig(default_grammar.path, extra_constraints=value)
        except (IndexError, AttributeError) as e:
            raise ValueError(f"Invalid grammar spec for {func_name}: {value}") from e
    else:
        raise ValueError(f"Unsupported grammar type for {func_name}: {type(value)}")


def process_parser_override(func_name: str, value: Any) -> InputParser:
    """Process parser override with proper validation."""
    if isinstance(value, InputParser):
        return value
    elif isinstance(value, str):
        val = value.strip()
        if val.startswith("<") and val.endswith(">"):
            return InputParser.for_nonterminal(val)
        else:
            raise ValueError(f"String parser spec must be nonterminal like '<number>' for {func_name}: {value}")
    elif isinstance(value, list):
        if all(isinstance(v, str) for v in value):
            return InputParser.for_grammar_pattern(*value)
        else:
            raise ValueError(f"List parser spec must contain only strings for {func_name}: {value}")
    else:
        raise ValueError(f"Invalid parser spec for {func_name}: {value}")


def get_override(func, override_dict: dict[str, Any], func_name: str, attr_name: str) -> Any:
    """Get override value from dict or function attribute."""
    return override_dict.get(func_name) or getattr(func, attr_name, None)


def register_class_functions(class_name: str, cls: type, config: PropertyInferenceConfig,
                             overrides: dict[str, dict[str, Any]], verbose: bool = False) -> int:
    """Register all functions from a class with their overrides."""
    function_count = 0

    for func_name, func in inspect.getmembers(cls, inspect.isfunction):
        try:
            # Get overrides for this function
            converter = get_override(func, overrides['converter'], func_name, '__converter__')
            comparator = get_override(func, overrides['comparator'], func_name, '__comparator__')
            grammar = get_override(func, overrides['grammar'], func_name, '__grammar__')
            parser = get_override(func, overrides['parser'], func_name, '__parser__')

            # Process grammar if needed
            if grammar and not isinstance(grammar, GrammarConfig):
                grammar = process_grammar_override(func_name, grammar, config.default_grammar)

            # Process parser if needed
            if parser and not isinstance(parser, InputParser):
                parser = process_parser_override(func_name, parser)

            # Create and register function
            fut = FunctionUnderTest(func, arg_converter=converter, result_comparator=comparator)
            config.add_function(fut, grammar=grammar, parser=parser)
            function_count += 1

            if verbose:
                print(f"  • Registered {class_name}.{func_name}")

        except Exception as e:
            print(f"Warning: Failed to register {class_name}.{func_name}: {e}", file=sys.stderr)

    return function_count


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Property Inference Engine - Analyze mathematical properties of functions",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                                    # Use default user_input.py
  %(prog)s -f my_functions.py                 # Analyze custom functions
  %(prog)s -f calc.py -e 500 -g custom.fan   # Custom settings
  %(prog)s --standard-registry -v            # Use full property set with verbose output
  %(prog)s --list-properties                  # Show available properties
  %(prog)s -p Commutativity Associativity    # Test specific properties only
  %(prog)s --timing --max-counterexamples 5  # Show timing with more counterexamples
        """
    )

    # Input options
    input_group = parser.add_argument_group('Input Options')
    input_group.add_argument(
        '-f', '--functions-file',
        type=str,
        default="input/user_input.py",
        help='Path to Python file containing functions to analyze (default: input/user_input.py)'
    )
    input_group.add_argument(
        '-c', '--class-name',
        type=str,
        default=None,
        help='Name of the class containing functions to analyze (default: all classes)'
    )

    # Property registry options
    registry_group = parser.add_argument_group('Property Registry Options')
    registry_mutex = registry_group.add_mutually_exclusive_group()
    registry_mutex.add_argument(
        '--minimal-registry',
        action='store_true',
        default=True,
        help='Use minimal property registry (default)'
    )
    registry_mutex.add_argument(
        '--standard-registry',
        action='store_true',
        help='Use standard (full) property registry'
    )

    # Test configuration
    config_group = parser.add_argument_group('Test Configuration')
    config_group.add_argument(
        '-e', '--examples',
        type=int,
        default=100,
        help='Number of test examples to generate (default: 100)'
    )
    config_group.add_argument(
        '--max-counterexamples',
        type=int,
        default=3,
        help='Maximum number of counterexamples to show (default: 3)'
    )
    config_group.add_argument(
        '-g', '--grammar',
        type=str,
        default="grammars/test.fan",
        help='Default grammar file to use (default: grammars/test.fan)'
    )
    config_group.add_argument(
        '--comparison-strategy',
        choices=['FIRST_COMPATIBLE', 'CONSENSUS', 'MOST_RESTRICTIVE'],
        default='FIRST_COMPATIBLE',
        help='Strategy for comparing results (default: FIRST_COMPATIBLE)'
    )
    config_group.add_argument(
        '--no-cache',
        action='store_true',
        help='Disable caching of generated inputs'
    )

    # Property selection
    property_group = parser.add_argument_group('Property Selection')
    property_group.add_argument(
        '-p', '--properties',
        nargs='*',
        help='Specific properties to test (if not specified, all properties are tested)'
    )
    property_group.add_argument(
        '--list-properties',
        action='store_true',
        help='List all available properties and exit'
    )

    # Output options
    output_group = parser.add_argument_group('Output Options')
    output_group.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    output_group.add_argument(
        '-q', '--quiet',
        action='store_true',
        help='Suppress all output except results'
    )
    output_group.add_argument(
        '--timing',
        action='store_true',
        help='Show execution timing information'
    )
    output_group.add_argument(
        '--json',
        action='store_true',
        help='Output results in JSON format'
    )
    output_group.add_argument(
        '-o', '--output',
        type=str,
        help='Write results to file instead of stdout'
    )

    # Advanced options
    advanced_group = parser.add_argument_group('Advanced Options')
    advanced_group.add_argument(
        '--dry-run',
        action='store_true',
        help='Show configuration without running tests'
    )

    return parser.parse_args()


def list_available_properties(registry):
    """List all available properties in the registry."""
    print("Available Properties:")
    print("=" * 50)
    properties = registry.get_all()
    for prop_name in properties:
        print(f"  • {prop_name}")
    print(f"\nTotal: {len(properties)} properties")


def validate_arguments(args):
    """Validate command line arguments."""
    errors = []

    # Check if functions file exists
    if not os.path.exists(args.functions_file):
        errors.append(f"Functions file not found: {args.functions_file}")

    # Check if grammar file exists (only if not using list-properties)
    if not args.list_properties and not os.path.exists(args.grammar):
        errors.append(f"Grammar file not found: {args.grammar}")

    # Validate examples count
    if args.examples <= 0:
        errors.append("Number of examples must be positive")

    # Validate max counterexamples
    if args.max_counterexamples < 0:
        errors.append("Max counterexamples must be non-negative")

    # Check for conflicting quiet/verbose flags
    if args.quiet and args.verbose:
        errors.append("Cannot use both --quiet and --verbose flags")

    if errors:
        print("Error: Invalid arguments:", file=sys.stderr)
        for error in errors:
            print(f"  • {error}", file=sys.stderr)
        sys.exit(1)


def setup_config(args):
    """Set up the PropertyInferenceConfig based on arguments."""
    # Build property registry
    if args.standard_registry:
        registry = create_standard_registry()
        if not args.quiet:
            print("Using standard property registry")
    else:
        registry = create_minimal_registry()
        if not args.quiet:
            print("Using minimal property registry")

    # Handle list properties request
    if args.list_properties:
        list_available_properties(registry)
        sys.exit(0)

    # Build base config
    default_parser = InputParser.for_numbers()

    # Set comparison strategy
    strategy_map = {
        'FIRST_COMPATIBLE': ComparisonStrategy.FIRST_COMPATIBLE,
        'CONSENSUS': ComparisonStrategy.CONSENSUS,
        'MOST_RESTRICTIVE': ComparisonStrategy.MOST_RESTRICTIVE
    }

    config = (PropertyInferenceConfig(registry)
              .set_default_grammar(args.grammar)
              .set_default_parser(default_parser)
              .set_max_counterexamples(args.max_counterexamples)
              .set_example_count(args.examples)
              .set_comparison_strategy(strategy_map[args.comparison_strategy])
              .set_use_input_cache(not args.no_cache))

    if args.verbose:
        print(f"Configuration:")
        print(f"  • Examples per test: {args.examples}")
        print(f"  • Max counterexamples: {args.max_counterexamples}")
        print(f"  • Grammar file: {args.grammar}")
        print(f"  • Comparison strategy: {args.comparison_strategy}")
        print(f"  • Use input cache: {not args.no_cache}")

    return config


def load_and_register_functions(config: PropertyInferenceConfig, args) -> PropertyInferenceConfig:
    """Load user module and register functions."""
    try:
        module = load_user_module(args.functions_file)
    except Exception as e:
        print(f"Error loading functions file: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        # Get user classes
        classes = get_user_classes(module, args.class_name)

        # Extract overrides
        overrides = extract_overrides(module)

        if args.verbose and any(any(d.values()) for d in overrides.values()):
            print("Found function overrides:")
            for override_type, override_dict in overrides.items():
                if override_dict:
                    print(f"  • {override_type}: {list(override_dict.keys())}")

        # Register functions from classes
        total_functions = 0
        for class_name, cls in classes:
            function_count = register_class_functions(class_name, cls, config, overrides, args.verbose)
            total_functions += function_count

        if not args.quiet:
            class_names = [name for name, _ in classes]
            print(f"Registered {total_functions} functions from {len(classes)} class(es): {', '.join(class_names)}")

        # Add specific properties if requested
        if args.properties:
            for prop_name in args.properties:
                try:
                    config.add_property_by_name(prop_name)
                    if args.verbose:
                        print(f"  • Added property: {prop_name}")
                except Exception as e:
                    print(f"Warning: Could not add property '{prop_name}': {e}", file=sys.stderr)

        return config

    except Exception as e:
        print(f"Error processing functions: {e}", file=sys.stderr)
        sys.exit(1)


def format_results(results: dict, args) -> str:
    """Format results for output."""
    if args.json:
        return json.dumps(results, indent=2, default=str)

    output_lines = []

    for func_name, result in results.items():
        output_lines.append(f"\n📊 Inferred Properties for {func_name}:")

        for prop, outcome in result["outcomes"].items():
            holds = outcome["holds"]
            tests_run = outcome["stats"]["total_count"]
            success_count = outcome["stats"]["success_count"]
            confidence = (success_count / tests_run * 100) if tests_run > 0 else 0.0
            status = "🟢" if holds else "🔴"

            decision = (
                f"{status} {prop} "
                f"(Confidence: {confidence:.1f}%; Tests run: {tests_run})"
            )
            output_lines.append(decision)

            for ex in outcome["counterexamples"]:
                output_lines.append(f"\t{ex}")

    return "\n".join(output_lines)


def main():
    """Main CLI entry point."""
    args = parse_arguments()

    # Validate arguments
    validate_arguments(args)

    if args.dry_run:
        print("🔍 Dry run mode - showing configuration without executing tests")
        print(f"Functions file: {args.functions_file}")
        print(f"Class name: {args.class_name or 'all classes'}")
        print(f"Examples: {args.examples}")
        print(f"Registry: {'standard' if args.standard_registry else 'minimal'}")
        print(f"Grammar file: {args.grammar}")
        print(f"Comparison strategy: {args.comparison_strategy}")
        print(f"Use cache: {not args.no_cache}")
        if args.properties:
            print(f"Properties to test: {', '.join(args.properties)}")
        else:
            print("Properties to test: all available")
        return

    try:
        # Setup configuration
        config = setup_config(args)

        # Load and register functions
        config = load_and_register_functions(config, args)

        # Run the analysis
        if not args.quiet:
            print("\n🚀 Running property inference analysis...")

        start_time = time.perf_counter() if args.timing else None

        engine = PropertyInferenceEngine(config)
        results = engine.run()

        end_time = time.perf_counter() if args.timing else None

        # Format and output results
        formatted_results = format_results(results, args)

        if args.output:
            with open(args.output, 'w') as f:
                f.write(formatted_results)
            if not args.quiet:
                print(f"✅ Results written to {args.output}")
        else:
            print(formatted_results)

        # Show timing if requested
        if args.timing and start_time and end_time:
            print(f"\n⏱️  Execution time: {end_time - start_time:.4f} seconds")

    except KeyboardInterrupt:
        print("\n❌ Operation cancelled by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
